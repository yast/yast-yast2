#!/usr/bin/perl -w
#
# Author: Martin Vidner <mvidner@suse.cz>
# based on ag_yp_makefile by Dan Vesely (dan@suse.cz)
#
# $Id$
#
# Agent for accessing sendmail and postfix maps described in
#  makemap(8) and postmap(1)
#

use ycp;
use strict;
use Errno qw(ENOENT);

# Global variables:
# The file specifies a map, but we represent it as a list to preserve
# preceding comments and the order of entries.
# list entries:
#  { "comment" => " foo\n bar\n", "key" => "root", "value" => "joe, \\root" }
#  that is, comments have the leading '#' stripped but not the newline.
# Before the first entry, there can be a leading comment, separated by
# a blank line.
my $leading_comment;
my @table;
my $trailing_comment;

my $modified;

# Parser features:

my $filename;
my $linenum;
my $line_comment;
my $line = "";
my $backslashed_line;

my $separator;
my $oseparator;
my $continue_escaped_newline;
my $continue_leading_blanks;

my $debug = defined($ARGV[0]) && $ARGV[0] eq "-d";

#
# routine to log and return error
#
sub log_error ( $ ) {
    my ($err_msg) = @_;
    y2error ($err_msg);
    return "false";
}

sub dumpit () {
    print STDERR "line: '$line' line_comment: '$line_comment'\n";
}

# create a map entry after it has been composed of split lines
sub parse_line ($)
{
    my $line = shift;

    # is this the first line?
    if ($line ne "")
    {
	if ($line =~ /^(.*?)$separator(.*)\n$/s)
	{
	    push (@table, { "comment" => $line_comment,
			    "key" => $1,
			    "value" => $2 });
	}
	else
	{
	    log_error ("No separator, $filename:$linenum '$line'");
	}
    }
}

#
sub parse_file ()
{
    $linenum = 0;
    $line = "";
    $line_comment = "";
    $backslashed_line = "";
    my $leading_comment_allowed = 1;

    $leading_comment = "";
    @table = ();
    $trailing_comment = "";

    if (!open (FILE, $filename))
    {
	y2error ("$filename: $!") unless ($! == ENOENT);
	# a missing file will be fixed by the module anyway
	# and y2cc starts all agents :(
	return;
    }

    while (<FILE>)
    {
	++$linenum;
	dumpit () if ($debug);

	# Escaped newlines: merge them before any other processing.
	# Is this one escaped?
	if ($continue_escaped_newline && /\\\n$/)
	{
	    print STDERR "$linenum:continued\n" if ($debug);
	    chomp; # \n
	    chop; # \\
	    $backslashed_line .= "$_ ";
	    next;
	}
	# Was there one already?
	if ($backslashed_line ne "")
	{
	    $_ = $backslashed_line . $_;
	    $backslashed_line = "";
	}


	# Accept comments
	if (/^\#(.*)/)
	{
	    print STDERR "$linenum:comment\n" if ($debug);
	    $trailing_comment .= "$1\n";
	}
	elsif (/^\n$/)
	{
	    if ($leading_comment_allowed)
	    {
		$leading_comment .= $trailing_comment;
		$trailing_comment = "";
	    }
	}
	else
	{
	    $leading_comment_allowed = 0;
	    # $line is the previous line, $_ is the current one
	    if (/^\s+(.*)/)
	    {
		if ($continue_leading_blanks)
		{
		    print STDERR "$linenum:leading blanks\n" if ($debug);
		    $line .= $_;
		    $line_comment .= $trailing_comment;
		    $trailing_comment = "";
		}
		else
		{
		    log_error ("Leading whitespace, $filename:$linenum");
		}
	    }
	    else
	    {
		    print STDERR "$linenum:regular\n" if ($debug);
		    # a regular line. process the _previous_ one
		    # because this one might continue

		    parse_line ($line);

		    # next buffer
		    $line = $_;
		    $line_comment = $trailing_comment;
		    $trailing_comment = "";
	    }
	}
    }
    # end of file, but we must not forget to process the buffer!
    parse_line ($line);
    # only a comment: make it a leading one
    if ($leading_comment_allowed)
    {
	$leading_comment .= $trailing_comment;
	$trailing_comment = "";
    }

    close (FILE);
}

# take a multiline string and write it to FILE with a hash before each line
sub write_comment ($)
{
    my $comment = shift;
    foreach my $line (split /\n/, $comment)
    {
	print FILE "\#$line\n";
    }
}
#
sub write_file ()
{
    return "true" if (! $modified);

    open (FILE, ">$filename.YaST2.new") or return log_error ("Creating file: $!");
    if ($leading_comment)
    {
	write_comment ($leading_comment);
	print FILE "\n";
    }
    foreach my $entry (@table)
    {
	write_comment ($entry->{"comment"});
	print FILE $entry->{"key"}, $oseparator, $entry->{"value"}, "\n";
    }
    write_comment ($trailing_comment);
    close (FILE);

    if (-f $filename)
    {
	rename $filename, "$filename.YaST2.save" or return log_error ("Creating backup: $!");
    }
    rename "$filename.YaST2.new", $filename or return log_error ("Moving temp file: $!");

    $modified = 0;
    return "true";
}

#
# MAIN cycle
#

y2milestone ("ag_mailtable started");

# read the agent arguments
$_ = <STDIN>;
# no input at all - simply exit
exit if ! defined $_;

# reply to the client (this actually gets eaten by the ScriptingAgent)
ycp::Return (undef);
print "\n";

my ($symbol, $config, @rest) = ycp::ParseTerm ($_);
if ($symbol ne "Mailtable")
{
    y2error ("The first command must be the configuration.(Seen '$_')");
    exit;
}
else
{
    $filename = $config->{"filename"};
    $continue_escaped_newline = $config->{"continue_escaped_newline"};
    $continue_leading_blanks = $config->{"continue_leading_blanks"};
    $separator = $config->{"colon"} ? qr/:\s+/ : qr/\s+/;
    $oseparator = $config->{"colon"} ? ":\t" : "\t";
}

parse_file ();
$modified = 0;
print STDERR scalar(@table), " items\n" if ($debug);

while ( <STDIN> )
{
    my ($command, $path, $argument) = ycp::ParseCommand ($_);

    if ($command eq "Dir")
    {
	if ($path eq ".")
	{
	    ycp::Return (["leading_comment", "meta", "table", "trailing_comment"]);
	}
	elsif ($path eq ".meta")
	{
	    ycp::Return (["filename"]);
	}
	else
	{
	    ycp::Return ([]);
	}
    }

    # Write command
    elsif ($command eq "Write")
    {
	my $result = "true";
	if ($path eq ".trailing_comment" && ! ref ($argument))
	{
	    $trailing_comment = $argument;
	    $modified = 1;
	}
	elsif ($path eq ".leading_comment" && ! ref ($argument))
	{
	    $leading_comment = $argument;
	    $modified = 1;
	}
	elsif ($path eq ".table" && ref ($argument) eq "ARRAY")
	{
	    @table = @{$argument};
	    $modified = 1;
	}
	elsif ($path eq "." && !defined ($argument))
	{
	    $result = write_file ();
	}
	else
	{
	    y2error ("Wrong path $path or argument: ", ref ($argument));
	    $result = "false";
	}

	ycp::Return ($result);
    }

    # Read command
    elsif ($command eq "Read")
    {
	if ($path eq ".table")
	{
	    ycp::Return (\@table);
	}
	elsif ($path eq ".trailing_comment")
	{
	    ycp::Return ($trailing_comment);
	}
	elsif ($path eq ".leading_comment")
	{
	    ycp::Return ($leading_comment);
	}
	elsif ($path eq ".meta.filename")
	{
	    ycp::Return ($filename);
	}
	else
	{
	    y2error ("Unrecognized path! '$path'");
	    ycp::Return (undef);
	}
    }


    # result: we should exit
    elsif ($command eq "result")
    {
	write_file ();
	exit;
    }

    # Unknown command
    else
    {
	y2error ("Unknown instruction $command or argument: ", ref ($argument));
	ycp::Return ("false");
    }
    print "\n";
}
