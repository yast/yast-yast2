# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AbstractMethod
  VERSION = ::T.let(nil, ::T.untyped)
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.ver(); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::Definition
  def create_gem_version_promoter(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, options=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, options); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(new_deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::LockfileGenerator
  def definition(); end

  def generate!(); end

  def initialize(definition); end

  def out(); end
end

class Bundler::LockfileGenerator
  def self.generate(definition); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Resolver::SpecGroup
  def platforms_for_dependency_named(dependency); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration::MoreFuture
  def backport_ext_builder_monitor(); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Cheetah
  BUILTIN_DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  READ = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)
end

class Cheetah::DefaultRecorder
  STREAM_INFO = ::T.let(nil, ::T.untyped)
end

class Class
  def json_creatable?(); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

class DidYouMean::DeprecatedIgnoredCallers
  def +(*_); end

  def <<(*_); end
end

class DidYouMean::DeprecatedIgnoredCallers
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_PREDEFINED_OBJECTS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def self.exists?(_); end
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  def sum(*_); end
end

class Enumerator
  def each_with_index(); end
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

Errno::ENOTSUP = Errno::EOPNOTSUPP

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class File
  def self.exists?(_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  USE_BUNDLER_FOR_GEMDEPS = ::T.let(nil, ::T.untyped)
end

class Gem::Dependency
  def pretty_print(q); end
end

class Gem::DependencyInstaller
  def _deprecated_gems_to_install(); end

  def add_found_dependencies(to_do, dependency_list); end

  def gather_dependencies(); end

  def gems_to_install(*args, &block); end
end

Gem::DependencyResolver = Gem::Resolver

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  def self.redirector(); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Licenses
  IDENTIFIERS = ::T.let(nil, ::T.untyped)
end

class Gem::List
  def pretty_print(q); end
end

class Gem::Package
  def realpath(file); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(len=T.unsafe(nil)); end

  def rewind(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def mtime(); end

  def mtime=(mtime); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::RemoteFetcher
  def api_endpoint(uri); end

  def correct_for_windows_path(path); end

  def s3_expiration(); end

  def sign_s3_url(uri, expiration=T.unsafe(nil)); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::RequestSet
  def pretty_print(q); end
end

Gem::RequestSet::GemDepedencyAPI = Gem::RequestSet::GemDependencyAPI

class Gem::Requirement
  def pretty_print(q); end
end

class Gem::Resolver::APISet
  def pretty_print(q); end
end

class Gem::Resolver::APISpecification
  def pretty_print(q); end
end

class Gem::Resolver::ActivationRequest
  def others_possible?(); end

  def pretty_print(q); end
end

class Gem::Resolver::BestSet
  def pretty_print(q); end
end

class Gem::Resolver::Conflict
  def pretty_print(q); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::DependencyRequest
  def pretty_print(q); end
end

class Gem::Resolver::GitSet
  def pretty_print(q); end
end

class Gem::Resolver::GitSpecification
  def pretty_print(q); end
end

class Gem::Resolver::IndexSet
  def pretty_print(q); end
end

class Gem::Resolver::IndexSpecification
  def pretty_print(q); end
end

class Gem::Resolver::InstalledSpecification
  def pretty_print(q); end
end

class Gem::Resolver::InstallerSet
  def pretty_print(q); end
end

class Gem::Resolver::LocalSpecification
  def pretty_print(q); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LockSet
  def pretty_print(q); end
end

class Gem::Resolver::LockSpecification
  def pretty_print(q); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::VendorSet
  def pretty_print(q); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

class Gem::Security::KEY_ALGORITHM
  def d(); end

  def dmp1(); end

  def dmq1(); end

  def e(); end

  def export(*_); end

  def initialize(*_); end

  def iqmp(); end

  def n(); end

  def p(); end

  def params(); end

  def private?(); end

  def private_decrypt(*_); end

  def private_encrypt(*_); end

  def public?(); end

  def public_decrypt(*_); end

  def public_encrypt(*_); end

  def public_key(); end

  def q(); end

  def set_crt_params(_, _1, _2); end

  def set_factors(_, _1); end

  def set_key(_, _1, _2); end

  def sign_pss(*_); end

  def to_der(); end

  def to_pem(*_); end

  def to_s(*_); end

  def to_text(); end

  def verify_pss(*_); end
  NO_PADDING = ::T.let(nil, ::T.untyped)
  PKCS1_OAEP_PADDING = ::T.let(nil, ::T.untyped)
  PKCS1_PADDING = ::T.let(nil, ::T.untyped)
  SSLV23_PADDING = ::T.let(nil, ::T.untyped)
end

class Gem::Security::KEY_ALGORITHM
  def self.generate(*_); end
end

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def re_sign_key(); end

  def sign(data); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::Source
  def api_uri(); end

  def pretty_print(q); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def bundled_gem_in_old_ruby?(); end

  def pretty_print(q); end

  def rubyforge_project(); end

  def to_ruby(); end

  def warning(statement); end
end

class Gem::Specification
  extend ::Enumerable
  extend ::Gem::Deprecate
  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.remove_spec(spec); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  NULL_DEVICE = ::T.let(nil, ::T.untyped)
end

class Gem::Version
  def pretty_print(q); end
end

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self._deprecated_datadir(gem_name); end

  def self.default_gems_use_full_paths?(); end

  def self.remove_unresolved_default_spec(spec); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
end

class Hash
  def self.try_convert(_); end
end

class IO
  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def ready?(); end

  def scanf(str, &b); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

class Installation::AutoinstIssues::List
  def <<(*args, &block); end

  def each(*args, &block); end

  def empty?(*args, &block); end
end

class Installation::AutoinstProfile::ElementPath
  def first(*args, &block); end

  def last(*args, &block); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def itself(); end

  def object_id(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class NameError
  include ::DidYouMean::Correctable
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  ADDITIONAL_Y2DIRS = ::T.let(nil, ::T.untyped)
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TMP_RUBY_PREFIX = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Packages::UpdateMessage
  def self.[](*_); end

  def self.members(); end
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def clone(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

class Scanf::FormatSpecifier
  def conversion(); end

  def count_space?(); end

  def initialize(str); end

  def letter(); end

  def match(str); end

  def matched(); end

  def matched_string(); end

  def mid_match?(); end

  def re_string(); end

  def to_re(); end

  def width(); end
end

class Scanf::FormatString
  def initialize(str); end

  def last_match_tried(); end

  def last_spec(); end

  def last_spec_tried(); end

  def match(str); end

  def matched_count(); end

  def prune(n=T.unsafe(nil)); end

  def space(); end

  def spec_count(); end

  def string_left(); end
  REGEX = ::T.let(nil, ::T.untyped)
  SPECIFIERS = ::T.let(nil, ::T.untyped)
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module SimpleIDN
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  ASCII_MAX = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  LABEL_SEPERATOR_RE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module SimpleIDN::Punycode
  ASCII_MAX = ::T.let(nil, ::T.untyped)
  BASE = ::T.let(nil, ::T.untyped)
  DAMP = ::T.let(nil, ::T.untyped)
  DELIMITER = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  INITIAL_N = ::T.let(nil, ::T.untyped)
  MAXINT = ::T.let(nil, ::T.untyped)
  SKEW = ::T.let(nil, ::T.untyped)
  TMAX = ::T.let(nil, ::T.untyped)
  TMIN = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def block_scanf(fstr); end

  def scanf(fstr, &b); end

  def shellescape(); end

  def shellsplit(); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

class Y2Packager::ReleaseNotesContentPrefs
  def self.[](*_); end

  def self.members(); end
end

module Yast
  def copy_arg(object); end

  def deep_copy(object); end

  def y2_logger(*_); end
  BACKTRACE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Yast::AbortException
end

class Yast::AbortException
end

class Yast::ArgRef
  def initialize(initial=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
end

class Yast::ArgRef
end

class Yast::Break
  def initialize(msg=T.unsafe(nil)); end
end

class Yast::Break
end

class Yast::Byteblock
end

class Yast::Byteblock
end

module Yast::CoreExt
end

module Yast::CoreExt::AnsiString
end

module Yast::CoreExt::AnsiString
end

module Yast::CoreExt
end

class Yast::External
  def initialize(magic); end

  def magic(); end
end

class Yast::External
end

class Yast::FunRef
end

class Yast::FunRef
end

class Yast::Path
  include ::Comparable
  def +(other); end

  def clone(); end

  def empty?(); end

  def initialize(value); end

  def size(); end
  COMPLEX_CHAR_REGEX = ::T.let(nil, ::T.untyped)
  SIMPLE_CHAR_REGEX = ::T.let(nil, ::T.untyped)
end

class Yast::Path
  def self.from_string(string); end
end

module Yast::Pkg
end

module Yast::Pkg
  def self.AddUpgradeRepo(*args); end

  def self.AnyResolvable(*args); end

  def self.CallbackAcceptFileWithoutChecksum(*args); end

  def self.CallbackAcceptUnknownDigest(*args); end

  def self.CallbackAcceptUnknownGpgKey(*args); end

  def self.CallbackAcceptUnsignedFile(*args); end

  def self.CallbackAcceptVerificationFailed(*args); end

  def self.CallbackAcceptWrongDigest(*args); end

  def self.CallbackAuthentication(*args); end

  def self.CallbackDestDownload(*args); end

  def self.CallbackDoneDownload(*args); end

  def self.CallbackDonePackage(*args); end

  def self.CallbackDoneProvide(*args); end

  def self.CallbackDoneRefresh(*args); end

  def self.CallbackDoneScanDb(*args); end

  def self.CallbackErrorScanDb(*args); end

  def self.CallbackFileConflictFinish(*args); end

  def self.CallbackFileConflictProgress(*args); end

  def self.CallbackFileConflictReport(*args); end

  def self.CallbackFileConflictStart(*args); end

  def self.CallbackFinishDeltaApply(*args); end

  def self.CallbackFinishDeltaDownload(*args); end

  def self.CallbackImportGpgKey(*args); end

  def self.CallbackInitDownload(*args); end

  def self.CallbackMediaChange(*args); end

  def self.CallbackMessage(*args); end

  def self.CallbackNotifyConvertDb(*args); end

  def self.CallbackNotifyRebuildDb(*args); end

  def self.CallbackPkgGpgCheck(*args); end

  def self.CallbackProblemDeltaApply(*args); end

  def self.CallbackProblemDeltaDownload(*args); end

  def self.CallbackProcessDone(*args); end

  def self.CallbackProcessNextStage(*args); end

  def self.CallbackProcessProgress(*args); end

  def self.CallbackProcessStart(*args); end

  def self.CallbackProgressConvertDb(*args); end

  def self.CallbackProgressDeltaApply(*args); end

  def self.CallbackProgressDeltaDownload(*args); end

  def self.CallbackProgressDownload(*args); end

  def self.CallbackProgressPackage(*args); end

  def self.CallbackProgressProvide(*args); end

  def self.CallbackProgressRebuildDb(*args); end

  def self.CallbackProgressReportEnd(*args); end

  def self.CallbackProgressReportProgress(*args); end

  def self.CallbackProgressReportStart(*args); end

  def self.CallbackProgressScanDb(*args); end

  def self.CallbackResolvableReport(*args); end

  def self.CallbackScriptFinish(*args); end

  def self.CallbackScriptProblem(*args); end

  def self.CallbackScriptProgress(*args); end

  def self.CallbackScriptStart(*args); end

  def self.CallbackSourceChange(*args); end

  def self.CallbackSourceCreateDestroy(*args); end

  def self.CallbackSourceCreateEnd(*args); end

  def self.CallbackSourceCreateError(*args); end

  def self.CallbackSourceCreateInit(*args); end

  def self.CallbackSourceCreateProgress(*args); end

  def self.CallbackSourceCreateStart(*args); end

  def self.CallbackSourceProbeEnd(*args); end

  def self.CallbackSourceProbeError(*args); end

  def self.CallbackSourceProbeFailed(*args); end

  def self.CallbackSourceProbeProgress(*args); end

  def self.CallbackSourceProbeStart(*args); end

  def self.CallbackSourceProbeSucceeded(*args); end

  def self.CallbackSourceReportDestroy(*args); end

  def self.CallbackSourceReportEnd(*args); end

  def self.CallbackSourceReportError(*args); end

  def self.CallbackSourceReportInit(*args); end

  def self.CallbackSourceReportProgress(*args); end

  def self.CallbackSourceReportStart(*args); end

  def self.CallbackStartConvertDb(*args); end

  def self.CallbackStartDeltaApply(*args); end

  def self.CallbackStartDeltaDownload(*args); end

  def self.CallbackStartDownload(*args); end

  def self.CallbackStartPackage(*args); end

  def self.CallbackStartProvide(*args); end

  def self.CallbackStartRebuildDb(*args); end

  def self.CallbackStartRefresh(*args); end

  def self.CallbackStartScanDb(*args); end

  def self.CallbackStopConvertDb(*args); end

  def self.CallbackStopRebuildDb(*args); end

  def self.CallbackTrustedKeyAdded(*args); end

  def self.CallbackTrustedKeyRemoved(*args); end

  def self.CheckGPGKeyFile(*args); end

  def self.ClearSaveState(*args); end

  def self.Commit(*args); end

  def self.CommitPolicy(*args); end

  def self.CompareVersions(*args); end

  def self.Connect(*args); end

  def self.CreateBackups(*args); end

  def self.CreateSolverTestCase(*args); end

  def self.DeleteGPGKey(*args); end

  def self.DoProvide(*args); end

  def self.DoRemove(*args); end

  def self.ExpandedName(*args); end

  def self.ExpandedUrl(*args); end

  def self.FilterPackages(*args); end

  def self.GPGKeys(*args); end

  def self.GetAdditionalLocales(*args); end

  def self.GetArchitecture(*args); end

  def self.GetBackupPath(*args); end

  def self.GetPackageLocale(*args); end

  def self.GetPackages(*args); end

  def self.GetSolverFlags(*args); end

  def self.GetTextLocale(*args); end

  def self.GetUpgradeRepos(*args); end

  def self.ImportGPGKey(*args); end

  def self.IsAnyResolvable(*args); end

  def self.IsAvailable(*args); end

  def self.IsManualSelection(*args); end

  def self.IsProvided(*args); end

  def self.IsSelected(*args); end

  def self.LastError(*args); end

  def self.LastErrorDetails(*args); end

  def self.PkgApplReset(*args); end

  def self.PkgAvailable(*args); end

  def self.PkgCommit(*args); end

  def self.PkgDU(*args); end

  def self.PkgDelete(*args); end

  def self.PkgGetFilelist(*args); end

  def self.PkgGetLicenseToConfirm(*args); end

  def self.PkgGetLicensesToConfirm(*args); end

  def self.PkgGroup(*args); end

  def self.PkgInstall(*args); end

  def self.PkgInstalled(*args); end

  def self.PkgLocation(*args); end

  def self.PkgMarkLicenseConfirmed(*args); end

  def self.PkgMediaCount(*args); end

  def self.PkgMediaNames(*args); end

  def self.PkgMediaPackageSizes(*args); end

  def self.PkgMediaSizes(*args); end

  def self.PkgNeutral(*args); end

  def self.PkgPath(*args); end

  def self.PkgProperties(*args); end

  def self.PkgPropertiesAll(*args); end

  def self.PkgQueryProvides(*args); end

  def self.PkgReset(*args); end

  def self.PkgSize(*args); end

  def self.PkgSolve(*args); end

  def self.PkgSolveCheckTargetOnly(*args); end

  def self.PkgSolveErrors(*args); end

  def self.PkgSrcInstall(*args); end

  def self.PkgSummary(*args); end

  def self.PkgTaboo(*args); end

  def self.PkgUpdateAll(*args); end

  def self.PkgVersion(*args); end

  def self.PrdGetLicenseToConfirm(*args); end

  def self.PrdHasLicenseConfirmed(*args); end

  def self.PrdLicenseLocales(*args); end

  def self.PrdMarkLicenseConfirmed(*args); end

  def self.PrdMarkLicenseNotConfirmed(*args); end

  def self.PrdNeedToAcceptLicense(*args); end

  def self.ProvidePackage(*args); end

  def self.RemoveUpgradeRepo(*args); end

  def self.RepositoryAdd(*args); end

  def self.RepositoryProbe(*args); end

  def self.RepositoryScan(*args); end

  def self.ResolvableCountPatches(*args); end

  def self.ResolvableDependencies(*args); end

  def self.ResolvableInstall(*args); end

  def self.ResolvableInstallArchVersion(*args); end

  def self.ResolvableInstallRepo(*args); end

  def self.ResolvableNeutral(*args); end

  def self.ResolvablePreselectPatches(*args); end

  def self.ResolvableProperties(*args); end

  def self.ResolvableRemove(*args); end

  def self.ResolvableSetSoftLock(*args); end

  def self.ResolvableUpdate(*args); end

  def self.Resolvables(*args); end

  def self.RestoreState(*args); end

  def self.RpmChecksig(*args); end

  def self.SaveState(*args); end

  def self.ServiceAdd(*args); end

  def self.ServiceAliases(*args); end

  def self.ServiceDelete(*args); end

  def self.ServiceForceRefresh(*args); end

  def self.ServiceGet(*args); end

  def self.ServiceProbe(*args); end

  def self.ServiceRefresh(*args); end

  def self.ServiceSave(*args); end

  def self.ServiceSet(*args); end

  def self.ServiceURL(*args); end

  def self.SetAdditionalLocales(*args); end

  def self.SetAdditionalVendors(*args); end

  def self.SetBackupPath(*args); end

  def self.SetPackageLocale(*args); end

  def self.SetSolverFlags(*args); end

  def self.SetTextLocale(*args); end

  def self.SetZConfig(*args); end

  def self.SkipRefresh(*args); end

  def self.SourceCacheCopyTo(*args); end

  def self.SourceChangeUrl(*args); end

  def self.SourceCreate(*args); end

  def self.SourceCreateBase(*args); end

  def self.SourceCreateType(*args); end

  def self.SourceDelete(*args); end

  def self.SourceEditGet(*args); end

  def self.SourceEditSet(*args); end

  def self.SourceFinishAll(*args); end

  def self.SourceForceRefreshNow(*args); end

  def self.SourceGeneralData(*args); end

  def self.SourceGetCurrent(*args); end

  def self.SourceLoad(*args); end

  def self.SourceLowerPriority(*args); end

  def self.SourceMediaData(*args); end

  def self.SourceMoveDownloadArea(*args); end

  def self.SourceProductData(*args); end

  def self.SourceProvideDigestedFile(*args); end

  def self.SourceProvideDirectory(*args); end

  def self.SourceProvideFile(*args); end

  def self.SourceProvideOptionalFile(*args); end

  def self.SourceProvideSignedDirectory(*args); end

  def self.SourceProvideSignedFile(*args); end

  def self.SourceRaisePriority(*args); end

  def self.SourceRawURL(*args); end

  def self.SourceRefreshNow(*args); end

  def self.SourceReleaseAll(*args); end

  def self.SourceRestore(*args); end

  def self.SourceSaveAll(*args); end

  def self.SourceScan(*args); end

  def self.SourceSetAutorefresh(*args); end

  def self.SourceSetEnabled(*args); end

  def self.SourceSetPriority(*args); end

  def self.SourceStartCache(*args); end

  def self.SourceStartManager(*args); end

  def self.SourceURL(*args); end

  def self.TargetAvailable(*args); end

  def self.TargetCapacity(*args); end

  def self.TargetDisableSources(*args); end

  def self.TargetFinish(*args); end

  def self.TargetGetDU(*args); end

  def self.TargetInit(*args); end

  def self.TargetInitDU(*args); end

  def self.TargetInitialize(*args); end

  def self.TargetInitializeOptions(*args); end

  def self.TargetInstall(*args); end

  def self.TargetLoad(*args); end

  def self.TargetRebuildDB(*args); end

  def self.TargetRemove(*args); end

  def self.TargetStoreRemove(*args); end

  def self.TargetUsed(*args); end

  def self.UrlKnownSchemes(*args); end

  def self.UrlSchemeIsDownloading(*args); end

  def self.UrlSchemeIsLocal(*args); end

  def self.UrlSchemeIsRemote(*args); end

  def self.UrlSchemeIsVolatile(*args); end

  def self.ZConfig(*args); end
end

class Yast::Term
end

class Yast::Term
end

class Yast::YCode
  def call(*_); end
end

class Yast::YCode
end

class Yast::YReference
  def call(*_); end
end

class Yast::YReference
end

module Yast
  def self.arg_ref(*args); end

  def self.call_yast_function(*_); end

  def self.deep_copy(object, options=T.unsafe(nil)); end

  def self.find_include_file(_); end

  def self.fun_ref(*args); end

  def self.import(mname); end

  def self.import_pure(_); end

  def self.include(target, path); end

  def self.symbols(_); end

  def self.term(*args); end

  def self.ui_component(); end

  def self.ui_component=(ui_component); end

  def self.ui_create(_, _1); end

  def self.ui_finalizer(); end

  def self.y2_logger(*_); end

  def self.y2paths(); end
end
